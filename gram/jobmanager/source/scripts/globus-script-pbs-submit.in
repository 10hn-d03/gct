#!@SH@

# Globus Job Manager PBS interface script for submitting a job 

# Author:		Doru Marcusiu (NCSA)
# Last Modified:	6/24/98
#
# This script builds a shell job script which is supplied as input
# to the PBS qsub command. The script is built based on information
# obtained from a file passed as the script's argument. This file
# contains a list of environment variables which are set by way
# of "sourcing" the file from this script. The evironment variables
# set as a result of this action are then used to characterize the
# user's job request. Once the job script has been submitted the
# PBS job id is appended to the file passed as an argument to this
# script to be used by other scripts at a later time.

# The temporary job script is created in a location defined by the
# TMP_DIR and PBS_JOB_SCRIPT name variables. This file is removed at
# the end of this script. 

	
qsub=@QSUB@
qstat=@QSTAT@
awk=@AWK@
mpirun=@MPIRUN@
rm=@RM@

	# Site-specific settings
	# Temporary directory in which job script will be built

TMP_DIR="/tmp"

	# File name to be used for temporary job script

PBS_JOB_SCRIPT=$TMP_DIR"/pbs_job_script."$$

arg_file=$1

	# Check for the argument file. If it does not exist
	# then return with an error immediately

if [ ! -f $arg_file ] ; then
   echo GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_BAD_SCRIPT_ARG_FILE@
   exit 1
fi
 
	# Source the argument file to set environment variables
	# defining all the job arguments

. $arg_file

	# If a logfile name has been defined then activate debug mode

if [ $grami_logfile = "/dev/null" ] ; then
    DEBUG_ECHO=:
else
    DEBUG_ECHO=echo
fi

	# Write initial debug information to logfile

$DEBUG_ECHO in gram_script_pbs_submit>> $grami_logfile
$DEBUG_ECHO "" >> $grami_logfile
$DEBUG_ECHO ======================================== >> $grami_logfile
$DEBUG_ECHO arguments recieved... >> $grami_logfile
$DEBUG_ECHO "logfile   =" $grami_logfile >> $grami_logfile
$DEBUG_ECHO "directory =" $grami_directory >> $grami_logfile
$DEBUG_ECHO "program   =" $grami_program >> $grami_logfile
$DEBUG_ECHO "args      =" $grami_args >> $grami_logfile
$DEBUG_ECHO "env       =" $grami_env >> $grami_logfile
$DEBUG_ECHO "count     =" $grami_count >> $grami_logfile
$DEBUG_ECHO "stdin     =" $grami_stdin >> $grami_logfile
$DEBUG_ECHO "stdout    =" $grami_stdout >> $grami_logfile
$DEBUG_ECHO "stderr    =" $grami_stderr >> $grami_logfile
$DEBUG_ECHO "maxtime   =" $grami_maxtime >> $grami_logfile
$DEBUG_ECHO "jobtype   =" $grami_jobtype >> $grami_logfile
$DEBUG_ECHO "myjob     =" $grami_myjob >> $grami_logfile
$DEBUG_ECHO "queue     =" $grami_queue >> $grami_logfile
$DEBUG_ECHO "project   =" $grami_project >> $grami_logfile
$DEBUG_ECHO "" >> $grami_logfile

	# The following several lines of code can be used to perform 2
	# additional error checks prior to job submission. The first check is
	# for the existance of the directory which the user requested
	# be the working directory. If it does not exist the script
	# returns an error and the job is not submitted. The second check
	# is for existance of the file requested by the user to be used for
	# stdin. If the file does not exist the scripts returns an error and
	# the job is not submitted.

	# These checks are only valid if performed on the file system to be used
	# by the host on which the job will run. But, this file system may not
	# be shared with host from which the job is submitted. Therefore, the
	# check does not make sense. If however the host from which the job 
	# will be submitted (i.e. the host running the globus gatekeeper)
	# shares file systems with all the hosts which may potentially
	# run the job these checks can be used. In order to have the job
	# manager perform these checks the following 2 sections of code
	# should *not* be commented out.


	# Check for existance of directory

#$DEBUG_ECHO testing for existance of directory [$grami_directory] >> $grami_logfile
#if [ -d $grami_directory ]; then
#   $DEBUG_ECHO directory [$grami_directory] found >> $grami_logfile
#    cd $grami_directory
#else
#   $DEBUG_ECHO directory [$grami_directory] DOES NOT exist; exiting with exit code 1 >> $grami_logfile
#   echo GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_BAD_DIRECTORY@
#   exit 1
#fi
#
	# Check for existance of stdin file if not /dev/null
#
#if [ $grami_stdin != "/dev/null" ]; then
#    $DEBUG_ECHO testing for existance of stdin file [$grami_stdin] >> $grami_logfile
#    if [ -r $grami_stdin ]; then
#        $DEBUG_ECHO stdin file [$grami_stdin] found and is readable >> $grami_logfile
#    else
#        $DEBUG_ECHO stdin file [$grami_stdin] DOES NOT exist or is not readable; exiting with exit code 1 >> $grami_logfile
#        echo GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_STDIN_NOTFOUND@
#        exit 1
#    fi
#fi

        # Check for non supported parameters and return an error
        # if found.


# Check for non supported parameters here. That is, if any of the RSL parameters
# which PBS can not support have been requested return an error.

$DEBUG_ECHO testing for unsupported parameters >> $grami_logfile

        # Verify existance of queue if queue parameter is not NULL
# if (unsupported parameters found)
#     $DEBUG_ECHO unsupported parameters found. Exiting with error. >> $grami_logfile
# else
#     $DEBUG_ECHO No unsupported parameters found. >> $grami_logfile
# fi
#

$DEBUG_ECHO testing for queue attribute specification >> $grami_logfile

if [ ! -z "${grami_queue}" ]; then
    $DEBUG_ECHO testing for existance of PBS queue [$grami_queue] >> $grami_logfile
    status=`qstat -Q $grami_queue`
    if (test "$?" -eq "0") then
        $DEBUG_ECHO PBS queue [$grami_queue] found >> $grami_logfile
    else
        $DEBUG_ECHO PBS queue [$grami_queue] DOES NOT exist; exiting with exit code 1 >> $grami_logfile
        echo GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_INVALID_QUEUE@
	exit 1
    fi
else
    $DEBUG_ECHO no queue attribute specified >> $grami_logfile
fi


	# Determine job request type

$DEBUG_ECHO testing for jobtype [$grami_jobtype] >> $grami_logfile
if [ $grami_jobtype = "mpi" -o $grami_jobtype = "multiple" -o $grami_jobtype = "single" ] ; then
   $DEBUG_ECHO jobtype [$grami_jobtype] acceptable >> $grami_logfile
else
   $DEBUG_ECHO invalid jobtype parameter [$grami_jobtype]; exiting with exit code 1 >> $grami_logfile
   echo GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_INVALID_JOBTYPE@
   exit 1
fi

	# Determining per process cpu time limit

$DEBUG_ECHO testing for per process cpu time limit >> $grami_logfile
if [ $grami_maxtime -eq 0 ] ; then
    cpu_time=0
    $DEBUG_ECHO No per process cpu time specified, using [queue default] per process cpu time >> $grami_logfile
else
    cpu_time="$grami_maxtime"
    $DEBUG_ECHO using [$cpu_time] minutes for max per process cpu time >> $grami_logfile
fi


	# Start building job script

$DEBUG_ECHO starting to build PBS job script >> $grami_logfile

echo "# PBS batch job script built by Globus job manager\n" > $PBS_JOB_SCRIPT

if [ ! -z "${grami_queue}" ] ; then
    echo "#PBS -q $grami_queue" >> $PBS_JOB_SCRIPT
fi

if [ ! -z "${grami_project}" ] ; then
    echo "#PBS -A $grami_project" >> $PBS_JOB_SCRIPT
fi

if [ $cpu_time -ne 0 ] ; then
    echo "#PBS -l pcput=$cpu_time:00" >> $PBS_JOB_SCRIPT
fi

echo "#PBS -o $grami_stdout" >> $PBS_JOB_SCRIPT
echo "#PBS -e $grami_stderr" >> $PBS_JOB_SCRIPT
echo "#PBS -l ncpus=$grami_count" >> $PBS_JOB_SCRIPT
#echo "#PBS -l nodes=$grami_count" >> $PBS_JOB_SCRIPT

	# Check for environment variables

#
#loop through all the environment variables.  Variables and values are seperate
#arguments.  While assembling var/value pairs add the specific syntax
#required for this scheduling system.
#
new_grami_env=""
if [ ! -z "${grami_env}" ] ; then
   eval set ${grami_env}
   x=0
   while [ "$#" -ne 0 ]; do
       if [ $x = 0 ] ; then
          new_grami_env="${new_grami_env}$1"
          x=1
       else
          x=0
          new_grami_env="${new_grami_env}=$1,"
       fi
 
       shift
   done
fi
 
echo "#PBS -v $new_grami_env" >> $PBS_JOB_SCRIPT

new_grami_args=""
if [ ! -z "${grami_args}" ] ; then
   eval set ${grami_args}
   new_grami_args="$*"
fi

	# Determine directory to be used as working directory 

echo "\n# Changing to directory as requested by user\n" >> $PBS_JOB_SCRIPT
echo "cd $grami_directory" >> $PBS_JOB_SCRIPT
 
	# Determining job request type

echo "\n# Executing job as requested by user\n" >> $PBS_JOB_SCRIPT
if [ $grami_jobtype = "mpi" ] ; then
    echo "${mpirun} -np $grami_count $grami_program $new_grami_args < $grami_stdin" >> $PBS_JOB_SCRIPT
elif [ $grami_jobtype = "multiple" ] ; then
	counter=0
	while (test "$counter" -lt "$grami_count")
	    do
            echo "$grami_program $new_grami_args < $grami_stdin &" >> $PBS_JOB_SCRIPT
	    counter=`expr $counter + 1`
	    done
        echo "wait" >> $PBS_JOB_SCRIPT;
else
    echo "$grami_program $new_grami_args < $grami_stdin" >> $PBS_JOB_SCRIPT
fi

$DEBUG_ECHO PBS job script successfully built >> $grami_logfile
$DEBUG_ECHO submitting PBS job script >> $grami_logfile

	# Execute qsub command

status=`${qsub} < $PBS_JOB_SCRIPT`
if (test "$?" -eq "0") then
   job_id=`echo $status | awk '{split($0,field,".");print field[1]"."field[2]}'`
   echo "grami_job_id=$job_id" >> $arg_file
   $DEBUG_ECHO "job submitted successfully!" >> $grami_logfile
   $DEBUG_ECHO "returning job state: 1" >> $grami_logfile
   echo "GRAM_SCRIPT_SUCCESS:@GLOBUS_GRAM_CLIENT_JOB_STATE_PENDING@"
else
   $DEBUG_ECHO "job *NOT* submitted successfully!" >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:@GLOBUS_GRAM_CLIENT_ERROR_JOB_EXECUTION_FAILED@"
   exit 1
fi

	# Remove temporary job script file

${rm} $PBS_JOB_SCRIPT

$DEBUG_ECHO "exiting gram_script_pbs_submit\n\n" >> $grami_logfile

exit
