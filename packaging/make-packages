#!/bin/bash

# This script iterates over directories in the subdirectory package-list
# and package-list-cdeps.
# Each directory should have a build-info and a pkg_data_src.gpt
# build-info should contain "name=" and "subdir=".
# make_source_package will create a GPT package containing subdir
# with the metadata in pkg_data_src.gpt

version="0.3"

usage () {
	echo $0: Usage:  
	echo $0 "[-p \"p1 p2 ...\"] [-t tag] [-i dir [-r] ] [-n] [-h] [-c | -j] [-a] [-s | -b] [-v] [-f]"
	echo "With no arguments, checkout and build all of GT3."
	echo
	echo "$0 -p \"p1 p2 ...\" 	Build packages p1, p2, ..."
	echo "$0 -t my_tag	Use \"-r my_tag\" in cvs commands"
	echo "$0 -t2 gt2_tag -t3 gt3_tag	Use two different tags"
	echo "$0 -i dir		Install into dir"
	echo "$0 -r		Make a release candidate.  Requires -i"
	echo "$0 -n 		Don't update the CVS checkout"
	echo "$0 -a		Use anonymous CVS checkouts"
	echo "$0 -h		Print this help message"
	echo "$0 -c		Just build C and C bindings"
	echo "$0 -j		Just build Java"
	echo "$0 -b		Install GT2 binaries, not source."
	echo "$0 -v		Pass -verbose to gpt-build."
	echo "$0 -f		Pass -force to gpt-build."
	echo
}

setup_environment() {
	#If user already has a JAVA_HOME, use it
	if [ x"$JAVA_HOME" = "x" ]; then
		# For MCS machines
		if [ -e /home/dsl/javapkgs/java-env-setup.sh ]; then
			source /home/dsl/javapkgs/java-env-setup.sh
		# ruly and mayed
		elif [ -d /usr/java/jdk1.3.1_07 ]; then
			export JAVA_HOME=/usr/java/jdk1.3.1_07
		# My laptop
		elif [ -d /usr/java/jdk1.3.1_06 ]; then
			export JAVA_HOME=/usr/java/jdk1.3.1_06
		else
			echo "I can't find JAVA_HOME for your system."
			echo "Please set JAVA_HOME before running this script"
			exit 1
		fi
	fi

	echo Using JAVA_HOME of $JAVA_HOME
	mkdir -p logs
}

# checkout_cvs_generic cvsdir checkoutdir module [ tag ] 
checkout_cvs_generic() {
	cvsdir=$1
	checkoutdir=$2
	module=$3
	cvstag=$4

	if [ x"$cvstag" = "x" ]; then
		cvs_opts="";
	else
		cvs_opts="-r $cvstag";
		echo "Using tag $cvstag"
	fi

	if [ x"$module" = "x" ]; then
		module="all"
	fi

	if [ $anonymous = 1 ]; then
		echo Using anonymous CVS ...
		export CVSROOT=:pserver:anonymous@cvs.globus.org:$cvsdir
	elif [ -d $cvsdir ]; then
		export CVSROOT=$cvsdir
	else
		export CVSROOT=cvs.globus.org:$cvsdir
		export CVS_RSH=ssh
	fi

	if [ ! -d $checkoutdir ]; then
		echo Making fresh CVS checkout of $1 "[module $module]"
		echo "Logging to logs/$2.log"
		mkdir $checkoutdir
		cd $checkoutdir
		cvs co $cvs_opts $module > ../logs/$2.log 2>&1
		cd ..
	elif [ $update = 1 ]; then
		echo "Updating CVS checkout of $1"
		echo "Logging to logs/$2-$f.log"
		# cvs stat ogsa-cvs/ogsa/impl/java/build.xml | grep Tag
		cd $checkoutdir
		for f in *; do
			cd $f
			cvs -z3 -qq up -dP > ../../logs/$2-$f.log 2>&1
			cd ..
		done
		cd ..
	else
		echo "Skipping CVS update"
	fi

	echo
}

# Checkout GT3 cvs
checkout_cvs() {
	if [ x${gt3tag} != "x" ]; then
		mytag=$gt3tag
	else
		mytag="$tag"
	fi

	checkout_cvs_generic /home/globdev/CVS/gridservices ogsa-cvs all $mytag
}

checkout_cvs_gt2() {
	if [ x${gt2tag} != "x" ]; then
		mytag = $gt2tag
	else
		mytag = "$tag"
	fi

	checkout_cvs_generic /home/globdev/CVS/globus-packages gt2-cvs all $mytag
}

checkout_cvs_gt2_autotools() {
	checkout_cvs_generic /home/globdev/CVS/globus-packages gt2-autotools side_tools $tag
}

# Build autotools, leave it on the path
build_gt2_autotools() {

	echo Installing GT2 Autotools ...

	if [ ! -d gt2-autotools ]; then
		checkout_cvs_gt2_autotools
		cd gt2-autotools

		echo Building GT2 autotools now
		echo Logging to logs/gt2-autotools.log
		./side_tools/build-autotools > ../logs/gt2-autotools.log 2>&1
	else
		echo Using existing GT2 autotools installation
		cd gt2-autotools
	fi

	export PATH=$PWD/autotools/bin:$PATH

	cd ..
}


#If GPT hasn't been built here yet, build it now.
#Some packages use GPT_LOCATION commands in build-info.

install_gpt_generic() {
	installdir=$1
	bundle=$2

	if [ -d $installdir ]; then
		echo Skipping GPT installation.
		echo Delete $installdir to force rebuild
		export GPT_LOCATION=`pwd`/$installdir
	else
		echo Installing gpt
		echo Logging to logs/$1.log
		tar xzf $bundle
		cd $installdir
		export GPT_LOCATION=`pwd`
		./build_gpt > ../logs/$1.log
		cd ..
	fi
	echo
}

install_gpt2() {
	install_gpt_generic gpt-2.2.9 fait_accompli/gpt-2.2.9-src.tar.gz
}

install_gpt3() {
	install_gpt_generic gpt-3.0rc1 fait_accompli/gpt-3.0rc1-src.tar.gz
}

install_gt2_binary() {
	echo Installing custom GT2 bundle
	$GPT_LOCATION/sbin/gpt-install fait_accompli/gt2_deps_gt3_beta-2.4_bin.tar.gz
	$GPT_LOCATION/sbin/gpt-postinstall
	echo
}

install_gt2_source() {
        flavor="gcc32dbg"

	echo Checking out GT2 CVS ...
        checkout_cvs_gt2 $gt2_branch 

	cd gt2-cvs

	if [ -d ../gt2-installation ]; then
		echo There is an existing gt2-installation, skipping rebuild.
		echo Delete gt2-installation to force a rebuild.
	else
		cd side_tools
		echo Building GT2 using ./cvs-build -noupdates -builddir=.. -installdir=$GLOBUS_LOCATION -everything $flavor
		echo Logging to logs/gt2-installation.log
        	./cvs-build -noupdates -builddir=.. -installdir=$GLOBUS_LOCATION -everything $flavor > ../../logs/gt2-installation.log 2>&1
		cd ..
	fi

	cd .. 
}

# Our GLOBUS_LOCATION was set when we installed GT2
# and we built autotools separately and put it on our path already.
# Need to unset gpt location - it's 2.x version, and there's a 1.x version in
# $GLOBUS_LOCATION.  This freaks cvs-build-ogsa out.

install_cdeps() {
		
	pushd ogsa-cvs/ogsa-c/build_tools

	OGPT=$GPT_LOCATION
	unset GPT_LOCATION

	# $GPT_LOCATION/sbin/gpt-build -nosrc gcc32dbg
	./cvs-build-ogsa ${verbose} --force gcc32dbg
	
	export GPT_LOCATION=$OGPT
	cd bin_packages
	$GPT_LOCATION/sbin/gpt-bundle -all -bindir=. -output=ogsa_cbindings_bin_bundle.tar.gz
	cd ../source_packages
	$GPT_LOCATION/sbin/gpt-bundle -all -srcdir=. -output=ogsa_cbindings_src_bundle.tar.gz 
	popd

	mkdir -p package-output
	cp ogsa-cvs/ogsa-c/build_tools/source_packages/ogsa_cbindings_src_bundle_src.tar.gz package-output
}

# Tar up the source directory with packaging data and filelist.
# Handle GPT-built source packages separately.
# make_source_package subdir-of-package-info
make_source_package() {
	if [ "$build" = "custom" ]; then
		echo Following custom build instructions for $name
		echo Logging to logs/${name}.log
		pwd
		$1/custom-build ogsa-cvs/$subdir $GPT_LOCATION $GLOBUS_LOCATION gcc32dbg > logs/${name}.log 2>&1
		echo
		return;
	fi

	export destdir=`pwd`/${name}-${version}-src/

    if [ x"$force" != "x" ]; then
        echo Rebuild forced, overwriting $destdir
        rm -rf $destdir
        rm -rf BUILD/$destdir
        rm -rf BUILD/$destdir.tar.gz
    fi

	if [ -d $destdir ]; then
		echo Skipping package $name;
		echo Delete $destdir to force rebuild;
	elif [ x$name = x ]; then
		echo Skipping missing packagedata
	else
		echo Creating source package for $name;

		if [ -d ogsa-cvs/$subdir ]; then
			pushd ogsa-cvs/$subdir
		else
			echo ogsa-cvs/$subdir does not exist, skipping.
			return
		fi


		# most packages
		if [ -f build.xml ]; then
			ant cleanAll > /dev/null
		# for core
		elif [ -f impl/java/build.xml ]; then
			ant -f impl/java/build.xml cleanAll > /dev/null
		fi

		popd

		echo Copying source dir to $destdir
		mkdir -p $destdir
		cp -Rp ogsa-cvs/$subdir $destdir/${name}

		if [ -f package-list/$name/pkg_data_src.gpt ]; then
			cp package-list/$name/pkg_data_src.gpt $destdir
		fi

		if [ -f package-list/$name/filelist ]; then
			cp package-list/$name/filelist $destdir
		fi

		# So GPT understands where the source lives
		touch $destdir/${name}/INSTALL
	fi
	
	unset destdir;
	echo
}

#Cleanup env for next iteration.
unset_env() {
	unset name subdir build gar;
}

#iter_generic dir
#dir should contain a file called build-info
iter_generic() {
	if [ -e $1/build-info ]; then
		if [ x$force = "x" ]; then
			if [ -e $1/IGNORE ]; then
				echo "$1/IGNORE exists, skipping $1"
			fi
		else
			if [ -e $1/IGNORE ]; then
				echo "$1/IGNORE exists, but -force is set.  Forcing anyway."
			fi
		fi

		source $1/build-info
		make_source_package $1
		unset_env
	else
		echo "Couldn't find $1/build-info"
		echo
	fi
}

#iterate over a directory
dir_iter() {
	for f in $1/*; do
		iter_generic $f
	done
}

#iterate over package names
package_iter() {
	for f in $@; do
		if [ -d package-list/$f ]; then
			iter_generic package-list/$f;
		elif [ -d package-list-cdeps/$f ]; then
			iter_generic package-list-cdeps/$f;
		else
			echo No package found matching the name $f
		fi
	done
}

collate_packages() {
	
	if [ ! -d package-output ]; then
		mkdir package-output
	fi

	for f in *-src; do
		echo Creating output package package-output/$f.tar.gz
		tar czf package-output/$f.tar.gz $f
	done

	#This is our gt3 src bundle.
	#Package it with the gt2 src bundle to make a distro

	$GPT_LOCATION/sbin/gpt-bundle -bn=gt3-all-src -bv=1.0 -srcdir=package-output -all

	if [ $release = 1 ]; then
		mkdir -p release-candidate/gt3-alpha3-source-installer
		cp gt3-all-src* release-candidate/gt3-alpha3-source-installer
		cp fait_accompli/gt3_alpha2_src_bundle-r1_src.tar.gz release-candidate/gt3-alpha3-source-installer
		cp fait_accompli/gpt-2.2.9-src.tar.gz release-candidate/gt3-alpha3-source-installer
		cp fait_accompli/install-gt3-alpha3-src release-candidate/gt3-alpha3-source-installer
		cp fait_accompli/OGSI.NET.zip release-candidate/gt3-alpha3-source-installer
		pushd release-candidate
		tar czf gt3_alpha3_src_installer.tar.gz gt3-alpha3-source-installer
		rm -fr gt3-alpha3-source-installer
		popd
	fi

}

install_bundle() {
	echo Installing into $dir
	export GLOBUS_LOCATION=$dir
	$GPT_LOCATION/sbin/gpt-build ${verbose} ${force} gt3-all-src-1.0-src_bundle.tar.gz gcc32dbg

	if [ $release = 1 ]; then
		echo Collecting GT3 binaries from $dir
		# This is now broken, since I install GT2 first.  Need to use an
		# explicit packaging_list for this.
		$GPT_LOCATION/sbin/gpt-pkg --installdir=$dir -all

		# This is our gt3 binary bundle
		# Package it with the gt2 binary bundle to make a distro
		# Do this before installing GT2 to avoid getting all those
		# packages also.
		$GPT_LOCATION/sbin/gpt-bundle -bn=gt3-all-bin -bv=1 -all -bindir=binaries

		mkdir -p release-candidate/gt3-alpha3-binary-installer
		mv gt3-all-bin* release-candidate/gt3-alpha3-binary-installer
		cp fait_accompli/gt3_alpha2_bin_bundle-r1_bin.tar.gz release-candidate/gt3-alpha3-binary-installer
		cp fait_accompli/gpt-2.2.9-src.tar.gz release-candidate/gt3-alpha3-binary-installer
		cp fait_accompli/install-gt3-alpha3-bin release-candidate/gt3-alpha3-binary-installer
		cp fait_accompli/OGSI.NET.zip release-candidate/gt3-alpha3-binary-installer
		cp fait_accompli/globus-rls-server-1.1-i686-pc-linux-gnu-bin.tar.gz release-candidate/gt3-alpha3-binary-installer
		pushd release-candidate
		tar czf gt3_alpha3_bin_installer.tar.gz gt3-alpha3-binary-installer
		rm -fr gt3-alpha3-binary-installer
		popd
	fi

	# Now redundant
	# echo Installing GT2 dep bundle into $dir
	# install_gt2_binary $dir

	if [ $release = 1 ]; then
		# This is gt3 core binary.  Distribute by itself.
		pushd BUILD/core-0.3-src/core/impl/java/build/
		tar czf gt3-core-alpha3.tar.gz ogsa-alpha-3/
		popd
		mv BUILD/core-0.3-src/core/impl/java/build/gt3-core-alpha3.tar.gz release-candidate

		# This is gt3 core source.  Distribute by itself.
		pushd ogsa-cvs/
		tar czf gt3-core-src-alpha3.tar.gz ogsa
		popd
		mv ogsa-cvs/gt3-core-src-alpha3.tar.gz release-candidate

		# This is the gars bundle.  Distribute by itself,
		# but it needs core installed first.
		mkdir gars/
		cp $dir/gars/* gars
		tar czf release-candidate/gt3-alpha3-gars.tar.gz gars
	fi

}

read_args() {
	dir=""
	install=-1
	buildjava=1
	buildc=1
	package=""
	release=-1
	tag=""
	gt2tag=""
	gt3tag=""
	gt2_branch="HEAD"
	update=1
	anonymous=0
	installbin=0
	verbose=""
	force=""

	while [ x$1 != "x" ]; do
		if [ $1 = "-t" ]; then
			export tag=$2;
			shift; shift;
		elif [ $1 = "-t2" ]; then
			export gt2tag=$2;
			shift; shift;
		elif [ $1 = "-t3" ]; then
			export gt3tag=$2;
			shift; shift;
		elif [ $1 = "-r" ]; then
			release=1;
			shift;
		elif [ $1 = "-p" ]; then
			package=$2;
			shift; shift;
		elif [ $1 = "-n" ]; then
			update=-1;
			shift;
		elif [ $1 = "-i" ]; then
			install=1;
			dir=$2;
			shift; shift;
		elif [ $1 = "-h" ]; then
			usage
			exit
		elif [ $1 = "-c" ]; then
			buildjava=-1;
			buildc=1;
			shift;
		elif [ $1 = "-j" ]; then
			buildjava=1;
			buildc=-1;
			shift;
		elif [ $1 = "-a" ]; then
			anonymous=1;
			shift;
		elif [ $1 = "-b" ]; then
			installbin=1;
			shift;
		elif [ $1 = "-v" ]; then
			verbose="-verbose";
			shift;
		elif [ $1 = "-f" ]; then
			force="-force";
			shift;
		else
			echo "Unrecognized option $1"
			usage
			exit
		fi
	done

	export buildc buildjava install tag update package onlyc release verbose;
}


# main

read_args "$@"
setup_environment

#Checkout GT3 cvs
checkout_cvs $tag

install_gpt2
#install_gpt3

#Build GT2 autotools, as globus_grim needs them
build_gt2_autotools

#The named packages case.
if [ x"$package" != "x" ]; then
	
	if [ x$dir != "x" ]; then
		export GLOBUS_LOCATION=$dir
	fi

	package_iter $package

	mkdir -p package-output

	for f in $package; do
		if [ -d ${f}*-src ]; then
			tar czf package-output/${f}-${version}.tar.gz ${f}*-src
			$GPT_LOCATION/sbin/gpt-build ${verbose} ${force} package-output/${f}-${version}.tar.gz gcc32dbg
		fi
	done

	echo Running gpt-postinstall, just in case.
	$GPT_LOCATION/sbin/gpt-postinstall
	exit
fi

# If user has requested installation, go ahead and put GT2 stuff there first.
if [ x$dir = "x" ]; then
	export GLOBUS_LOCATION="gt2-installation"
else
	export GLOBUS_LOCATION=$dir
fi

#This is the poor man's dependency code ...
if [ $buildjava = 1 ]; then
	echo Building Java-only packages
	dir_iter package-list
	echo

	collate_packages
	if [ $install = 1 ]; then
		install_bundle
	fi
fi

if [ $buildc = 1 ]; then
	if [ $installbin = 1 ]; then
		install_gt2_binary
	else
		install_gt2_source
	fi

	echo Building C-dependent packages
	install_cdeps
	dir_iter package-list-cdeps
fi

echo Running gpt-postinstall, just in case.
$GPT_LOCATION/sbin/gpt-postinstall
