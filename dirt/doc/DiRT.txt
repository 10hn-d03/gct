-------------------------------------
DiRT:  Distribution Revision Tracking
-------------------------------------

DiRT is a method of allowing Globus Toolkit(tm) components to include information that allows the identification of the exact revisions of all source files that make up a package, module, or program.  It is tightly coupled with CVS.

DiRT currently provides a timestamp and an cvs branch id that, together, can be used with cvs to checkout the code as it was at that timestamp, on that branch.  This information is maintained in a file (we'll call it the 'dirt' file) that will appear in every checkout of a package making use of DiRT.  This information can be integrated into Globus' packages in many ways.  

The need for DiRT was prompted by the potential support problem caused by users mixing and matching different revisions of packages in a Globus installation.  We simply cannot depend on being able to identify what code a user is having a problem with by the package version alone (accessible with gpt_verify).

In summary, DiRT updates a 'dirt' file associated with every 'enabled' package every time a 'cvs commit' is done within that package.  Details follow.

--------------------------
What is DiRT comprised of?
--------------------------

DiRT is comprised of 2 configuration files, some perl scripts, and any number of template files.  The active versions of these files are located in $CVSROOT/dirt_active (where CVSROOT is  /home/globdev/CVS/globus-packages). They can also be checked out and modified via 'cvs checkout dirt' with the same CVSROOT.  (Note:  When changes are committed to dirt, the dirt_active dir is automatically updated)  A detailed description of these files follows:

dirt/package.def
----------------
This file is used to specify which packages should be enabled for DiRT processing and which template file should be used.  It contains lines of the form:

<package name>  <package dir>  <template file>

package name:  Any label; will most likely actually match a package's
    name
package dir:   The is the dir you want the processed template file to
    appear in.  This will normally be in the package's root dir (along
    side bootstrap)
    The path must be relative to CVSROOT and NOT end with a '/'
template file:  The template file to parse into the package's root.  The
    strings @DIRT_TIMESTAMP@ and @DIRT_BRANCH_ID@ will be substituted for
    the correct values.  
    This template file must reside in the dirt/templates dir

for example:

globus_common          common/source            dirt.sh
globus_io              io/source                some_file
globus_ssl_utils       gsi/ssl_utils/source     version.sh
globus_gssapi_gsi      gsi/gssapi/source        dirt.sh

dirt/branch.def
---------------
This file is used to map the branch names to an integer id.  This id is what is provided by DiRT (along with a timestamp).  All id's here should be unique and MUST be unique for the benefits of DiRT to be reaped.  

Note: The trunk always uses an id of 1 and, if a branch is encountered that is not listed here, 0 will be used as the id and the user (the person committing the change on that branch) will be warned.

entries have the format:

  <branch name> <unique id>

for example:

globus-beta-branch                  2
globus-beta-branch-sub-versions     3
window                              4
my_branch                           5

dirt/scripts/dirt-update.pl
---------------------------
This is the workhorse script.  It is intended to be run by cvs from its loginfo file.  It is invoked at commit time with the modified repository as an argument.  CVS provides the list of modified files via stdin.  This script determines when it is necessary to update the 'dirt' file and does so.  For details on its operation, see 'How exactly does DiRT work?'

dirt/scripts/dirt-get-branch-name.pl
------------------------------------
This is a utility script for users.  It simply reads the branch.def file to map a branch id argument to a branch name.

dirt/scripts/dirt-convert-time.pl
---------------------------------
This is a utility script for users.  It converts the unix timestamp that DiRT stores in 'dirt' files to a form that can be passed to cvs.  (ex: 'cvs checkout -r `dirt-get-branch-name.pl 3` -D"`dirt-convert-time.pl 1013535996`" <module>')

dirt/templates/<template file>
------------------------------
This is one of the template files named in package.def.  It can contain anything.  The only things of concern to DiRT are the two strings @DIRT_TIMESTAMP@ and @DIRT_BRANCH_ID@.  Every time a package is modified, the template will be re parsed, replacing @DIRT_TIMESTAMP@ and @DIRT_BRANCH_ID@ with the correct values and storing this parsed file with the package.

---------------------------------
What do I have to do to use DiRT?
---------------------------------
Well, first... anytime there is a branch, it should be entered into the branch.def file with a unique id.

Then, you need to create a template file and add it to dirt's template dir (or use an existing one).  As an example, we'll create a simple one:

% cvs co dirt
% cd dirt/templates
% cat > version.sh
DIRT_TIMESTAMP=@DIRT_TIMESTAMP@
DIRT_BRANCH_ID=@DIRT_BRANCH_ID@
^D
% cvs add version.sh
% cvs commit -m 'Added new template file for my_package'

(Note:  anytime something is committed to dirt, dirt_active is automatically updated.  This behavior mimics modifications to the CVSROOT administrative module)

Now, we need to enable DiRT for the package.  Add an entry in package.def:

globus_my_package  path/to/my_package version.sh

Note that the path specified is where the parsed version.sh is going to end up.  The information specified in the parsed version.sh will reflect changes to all files in and below the specified path.

We have just enabled DiRT for my_package.  However, none of the branches or trunk will contain this parsed 'dirt' file until we explicitly request it.  In fact, any changes that are committed to an enabled package that has not 'requested' the version file will receive a warning: 

DiRT Warning: Package defined for DiRT but no users

To 'request' this file, we simply add a dummy file by the same name and commit that.  Once this is done, DiRT will provided as long as that file exists.

check out the branch (or trunk) that you need to contain the 'dirt' file, add a dummy version.sh and commit it.

% cvs checkout -r my_branch <module that contains my_package>
% cd path/to/my_package
% touch version.sh
% cvs add version.sh
% cvs commit -m 'Requesting DiRT for version.sh' version.sh
....
DiRT: version.sh has been updated.
DiRT: You should do a cvs update in this package's root directory
% cvs update
U version.sh
% cat version.sh
DIRT_TIMESTAMP=1013552864
DIRT_BRANCH_ID=5
%

From now on, any modifications made to files in or below path/to/my_package will cause version.sh to be updated and you will see 

DiRT: version.sh has been updated.
DiRT: You should do a cvs update in this package's root directory

This process has to be repeated for every branch and package that wants the 'dirt' file.  (Unless that branch has a branch point that already had a version file.  In this case, it will automatically be inherited)

If you remove version.sh later (ie, you do a cvs remove on it), DiRT will not put it back unless it is 'requested' again later.  Also, simply removing the package entry in package.def will not cause all of the 'dirt' files to be removed.  It will only prevent them from being updated any further.  This should ONLY be done when there are no longer any active branches making use of the 'dirt' file.

-------------------------------------------------
What is an example use of the what DiRT provides?
-------------------------------------------------
To continue from the example above, lets make use of the version.sh file.  Let's say we have a script that gets installed by my_package.  Currently, there is no way to identify the exact revision of this script.

Let's assume that this script is already processed by the configure script (ie, it was named 'script.in', after configure we have 'script').  Within this script we can now add a '--version' flag that will be able to not only print out the package revision, but also the timestamp and branch-id.

A line like the following would exist in script.in:

VERSION_STRING="@VERSION@.@DIRT_TIMESTAMP@-@DIRT_BRANCH_ID@"

The configure script would source the contents of version.sh and use those values to process script.in (assume VERSION is the package version and already known to the configure process).  If we use the example version.sh file above, we might have a line like the following in script:

VERSION_STRING="2.1.1013552864-5"

(If this would be confusing to users, we could have a version flag and a verbose version flag.  The first would show only '2.1', while the other would show '2.1.1013552864-5')

Now, if a user has a problem with this script, we can request the version string from them and either use it to identify whether the problem has already been fixed since (by using cvs log) or we can check out the exact version of the script they have with:

cvs checkout -r `dirt-get-branch-name.pl 5` -D"`dirt-convert-time.pl 1013552864`" <module containing 'script'>

--------------------------------
What do I need to be careful of?
--------------------------------

For DiRT to be useful, it is important that a branch id always map to one and only one branch tag.  This also implies that the mapping should never change.  This branch id to branch name mapping is the only way of retrieving an image of the source depicted by the timestamp and branch id.

Template files should never change once in use.  Unless this change is purely aesthetic or documentative.  The reason is because the version files in all branches are reconstructed from scratch from this template with every modification.  To make a major change in a template file may break previous branches depending on its old format.  If this behavior poses a problem, I will add support for specifying a revision of a template file in the package.def (this will require a few other changes also, see limitations section).

If, for some reason, you check out a file in a package using DiRT by using a **numeric** branch id (because, you're nuts?) instead of the symbolic tag name, DiRT will not be able to reflect that modification back to a 'dirt' file.

---------------------------
How exactly does DiRT work?
---------------------------

This will be the common case explanation using the psuedo code for dirt-update.pl.  However, the dirt-update.pl script was written to handle some insane special cases which might occur if someone thought they were a CVS guru.  The script is thoroughly documented.  Take a look if you want more details.

Verify that all config files exist

search package.def file to see if the modified repository is being 'watched' by DiRT
    if so, get the package location and template filename from
        package.def
    else, exit

See if the RCS file for the 'dirt' file exists in the package location
    if it doesnt, then noone has 'requested' the 'dirt' file yet
        warn about DiRT enabled but no users
        exit

Check the cvs change log (available on stdin) to see what branch(es) have been changed

Verify that the 'dirt' file has been requested (and still exists) for the given branch(es).
    if not, exit
    
Lookup numeric branch id in branch.def
   if branch doesnt exist, use 0 and warn user

Lock the package's root dir (cvs may have already done this for us)
    if someone else has the lock, sleep 15 secs and try again

Re parse the template file, substituting @DIRT_TIMESTAMP@ and @DIRT_BRANCH_ID@ with the appropriate values

commit this new 'dirt' file with rcs' 'ci' command specifying the correct branch and timestamp to use.

unlock package's root dir (if cvs didnt do it for us)

    

-----------------------------------------------
What are the limitations/known issues with DiRT?
-----------------------------------------------

- ignores updates to files checked out with numeric branches
- no template revision tracking
- I only use the first matching entry in package.defs file.  If I were to read all, I could allow multiple files and or files at different levels of a package.  For example, there could be a 'dirt' file in every dir of a package each reflecting the changes to all files in its own and all dirs below it.
